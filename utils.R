rep.row<-function(x,n){
  matrix(rep(x,each=n),nrow=n)
}
rep.col<-function(x,n){
  matrix(rep(x,each=n), ncol=n, byrow=TRUE)
}
spliner <- function(data){
  index_NA <- is.na(data)
  data <- na.approx(data)
  data <- zooToMatrix(data)
  res <- list(data,index_NA)
  return(res)
}
trimmer_hard <- function(x){
  x <- na.trim(x)
  return(x)
}
trimmer_soft <- function(data,tolerance){
  #tolerance tells us how many % of data on a given row needs
  #to be missing until we remove the whole row
  #if tolerance = 1 then we remove row only if 100% of all vars have a missing value in the row
  #if tolerance = 0.7,  remove if already 70% of the vars are missing
  periods <- dim(data)[1]
  vars <- dim(data)[2]
  index_NA <- is.na(data)
  remove_index <- rowSums(index_NA*1)>=(tolerance*vars)
  lead_remove <- cumsum(remove_index)==(1:periods)
  end_remove <- rev(cumsum(rev(remove_index))==(1:periods))
  index_ofall_removed <- lead_remove|end_remove
  data_trimmed <- data[!index_ofall_removed,]
  return(data_trimmed)
}
zooToMatrix <- function(data){
  rows <- dim(data)[1]
  cols <- dim(data)[2]
  res <- matrix(data,rows,cols)
  return(res)
}
blockDiag <- function(...){  
  matrixList<-list(...)
  if(is.list(matrixList[[1]])) matrixList<-matrixList[[1]]
  
  dimensions<-sapply(matrixList,FUN=function(x) dim(x)[1])
  finalDimension<-sum(dimensions)
  finalMatrix<-matrix(0,nrow=finalDimension,ncol=finalDimension)
  index<-1
  for(k in 1:length(dimensions)){
    finalMatrix[index:(index+dimensions[k]-1),index:(index+dimensions[k]-1)]<-matrixList[[k]]
    index<-index+dimensions[k]
  }
  return(finalMatrix)
}
vecFun <- function(x){
  x <- matrix(x,dim(x)[1]*dim(x)[2],1)
  return(x)
}
getDim <- function(x){
  if(is.matrix(x)){
    res <- dim(x)
    return(res)
  }else if(is.vector(x)){
    res <- length(x)
    return(res)
  }
}

remNaNs<- function(X,options){
  t = dim(X)[1]
  N = dim(X)[2]
  
  method = options$method
  k = options$k
  indNaN = is.na(X)
  # switch different cases
  # switch in R seems confusing;use if condition instead
  
  if(method == 1){  # replace all the missing values
    for (i in 1:N){
      x <- X[, i]
      # first replace missing values as median
      x[indNaN[,i]] <- median(x, na.rm = TRUE)
      # using new x to compute moving average
      b = rep(1/(2*k+1), 2*k+1)
      a = c(1)
      y = c(head(x, n=1)* rep(1, k), x, tail(x, n=1) * rep(1, k))
      x_MA = filter(b,a,y)
      x_MA = x_MA[2*k + 1 : length(x_MA)]
      # use MA to fill NaNs
      x[indNaN[,i]] = x_MA[indNaN[,i]]
      X[,i] = x
    }
  }
  else if(method == 2){ #replace missing values after removing leading and closing zeros
    rem1 = (rowSums(indNaN) > N*0.8)
    nanLead = (cumsum(rem1) == (1:t))
    nanEnd = rev(cumsum(rev(rem1)) == (1:t))
    nanLE = (nanLead | nanEnd)
    X <- X[!nanLE,]
    indNaN = is.na(X)
    for (i in 1:N){
      x = X[,i]
      isnanx = is.na(x)
      t1 = min(which(!isnanx), na.rm = TRUE)
      t2 = max(which(!isnanx), na.rm = TRUE)
      # using the default method "hmm" gives us the closest value to one generated by matlab code, 
      # but not exactly the same IN THE BEGINNING. We need to investiage this more in the future.
      # x_fmm = x
      # x_fmm[t1:t2] = spline(which(!isnanx), x[which(!isnanx)], n = length(t1:t2), method = "fmm", ties = mean)$y 
      x[t1:t2] = spline(which(!isnanx), x[which(!isnanx)], n = length(t1:t2))$y 
      isnanx = is.na(x)
      x[which(isnanx)] = median(x, na.rm = TRUE)
      b = rep(1/(2*k+1), 2*k+1)
      a = c(1)
      y = c(head(x, n=1)* rep(1, k), x, tail(x, n=1) * rep(1, k))
      # use MA to fill NaNs
      x_MA = filter(b,a,y)
      x_MA = x_MA[2*k + 1 : length(x_MA)]
      x[which(isnanx)] = x_MA[which(isnanx)]
      X[,i] = x
    }
  }  
  else if(method == 3){
    rem1 = (rowSums(indNaN) == N)
    nanLead = (cumsum(rem1) == (1:t))
    nanEnd = rev(cumsum(rev(rem1)) == (1:t))
    nanLE = (nanLead | nanEnd)
    X <- X[!nanLE,]
    indNaN = is.na(X)
  } 
  else if(method == 4){
    rem1 = (rowSums(indNaN) == N)
    nanLead = (cumsum(rem1) == (1:t))
    nanEnd = rev(cumsum(rev(rem1)) == (1:t))
    nanLE = (nanLead | nanEnd)
    X <- X[!nanLE,]
    indNaN = is.na(X)
    for (i in 1:N){
      x = X[,i]
      isnanx = is.na(x)
      t1 = min(which(!isnanx), na.rm = TRUE)
      t2 = max(which(!isnanx), na.rm = TRUE)
      # using the default method "hmm" gives us the closest value to one generated by matlab code, 
      # but not exactly the same IN THE BEGINNING. We need to investiage this more in the future.
      # x_fmm = x
      # x_fmm[t1:t2] = spline(which(!isnanx), x[which(!isnanx)], n = length(t1:t2), method = "fmm", ties = mean)$y 
      x[t1:t2] = spline(which(!isnanx), x[which(!isnanx)], n = length(t1:t2))$y 
      isnanx = is.na(x)
      x[which(isnanx)] = median(x, na.rm = TRUE)
      b = rep(1/(2*k+1), 2*k+1)
      a = c(1)
      y = c(head(x, n=1)* rep(1, k), x, tail(x, n=1) * rep(1, k))
      # use MA to fill NaNs
      x_MA = filter(b,a,y)
      x_MA = x_MA[2*k + 1 : length(x_MA)]
      x[which(isnanx)] = x_MA[which(isnanx)]
      X[,i] = x
    }
  } 
  else if(method == 5){
    indNaN = is.na(X)
    for (i in 1:N){
      x = X[,i]
      isnanx = is.na(x)
      t1 = min(which(!isnanx), na.rm = TRUE)
      t2 = max(which(!isnanx), na.rm = TRUE)
      # using the default method "hmm" gives us the closest value to one generated by matlab code, 
      # but not exactly the same IN THE BEGINNING. We need to investiage this more in the future.
      # x_fmm = x
      # x_fmm[t1:t2] = spline(which(!isnanx), x[which(!isnanx)], n = length(t1:t2), method = "fmm", ties = mean)$y 
      x[t1:t2] = spline(which(!isnanx), x[which(!isnanx)], n = length(t1:t2))$y 
      isnanx = is.na(x)
      x[which(isnanx)] = median(x, na.rm = TRUE)
      b = rep(1/(2*k+1), 2*k+1)
      a = c(1)
      y = c(head(x, n=1)* rep(1, k), x, tail(x, n=1) * rep(1, k))
      # use MA to fill NaNs
      x_MA = filter(b,a,y)
      x_MA = x_MA[2*k + 1 : length(x_MA)]
      x[which(isnanx)] = x_MA[which(isnanx)]
      X[,i] = x
    } 
  }
  res <- list(xBal = X, ind=indNaN)
  names(res) <- c("X", "indNaN")
  return(res)
}
